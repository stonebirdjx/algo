<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [:point_right:概念简介](#point_right%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B)
- [二叉树种类](#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A7%8D%E7%B1%BB)
  - [普通二叉树](#%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91)
  - [完全二叉树](#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91)
  - [满二叉树](#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91)
  - [:point_right:二叉搜索树](#point_right%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91)
    - [code-golang](#code-golang)
    - [code-python](#code-python)
  - [:point_right:AVL平衡二叉树 -- 细品](#point_rightavl%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91----%E7%BB%86%E5%93%81)
    - [code-golang](#code-golang-1)
    - [code-python](#code-python-1)
  - [:point_right:红黑树](#point_right%E7%BA%A2%E9%BB%91%E6%A0%91)
    - [code-golang](#code-golang-2)
    - [code-python](#code-python-2)
  - [:point_right:B树](#point_rightb%E6%A0%91)
    - [code-golang](#code-golang-3)
    - [code-python](#code-python-3)
  - [B+树](#b%E6%A0%91)
    - [code-golang](#code-golang-4)
    - [code-python](#code-python-4)
- [:point_right:二叉树遍历](#point_right%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86)
    - [:point_right:code-golang](#point_rightcode-golang)
    - [:point_right:code-python](#point_rightcode-python)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# :point_right:概念简介

树结构是一种包括节点(nodes)和边(edges)的拥有层级关系的一种结构

二叉树是一种简单的树，它的每个节点最多只能包含两个孩子。

![img](./images/erchatree.PNG)

- 根节点(root): 树的最上层的节点，任何非空的树都有一个节点
- 路径(path): 从起始节点到终止节点经历过的边
- 父亲(parent)：除了根节点，每个节点的上一层边连接的节点就是它的父亲(节点)
- 孩子(children): 每个节点由边指向的下一层节点
- 兄弟(siblings): 同一个父亲并且处在同一层的节点
- 子树(subtree): 每个节点包含它所有的后代组成的子树
- 叶子节点(leaf node): 没有孩子的节点成为叶子节点

# 二叉树种类

## 普通二叉树

每个节点最多有两个子节点，左子节点和右子节点。

## 完全二叉树

完全二叉树是一种特殊的二叉树，除了最后一层节点可以不满，其他层节点都必须是满的二叉树。在完全二叉树中，最后一层节点从左向右排列，不留空缺。

![](./images/putongerchatree.PNG)

> 完全二叉树具有一些特殊的性质，可以用于设计一些高效的数据结构，例如堆、哈希表等，也可以用于一些算法的优化，例如二分查找、贪心算法等。

## 满二叉树

满二叉树是一种特殊的二叉树，除了叶子节点，每个节点都有两个子节点，且所有叶子节点都在同一层。

![img](./images/mantree.PNG)

> 满二叉树的节点数目比普通二叉树更为确定，因此可以在一些需要确定节点数目的场合使用满二叉树。例如，满二叉树可以用于设计哈夫曼树、B树等数据结构，还可以用于算法的优化，例如二分查找、堆排序等。

## :point_right:二叉搜索树

二叉搜索树（Binary Search Tree，简称BST）是一种二叉树，其中每个节点都包含一个键值，且对于每个节点，其左子树中的所有节点的键值都小于该节点的键值，右子树中的所有节点的键值都大于该节点的键值。

二叉搜索树的特点：

1. 左子树中的所有节点的键值都小于根节点的键值。
2. 右子树中的所有节点的键值都大于根节点的键值。
3. 左右子树也分别是二叉搜索树。
4. 没有重复的节点。

![img](./images/bst.PNG)

> 中序遍历得到一个递增的有序序列。因此，中序遍历是二叉搜索树中最常用的遍历方法。
>
> 二叉搜索树的查找、插入和删除操作的时间复杂度都为O(log n)，其中n为节点数目。但是如果二叉搜索树退化为链表，那么操作的时间复杂度就会退化为O(n)。因此，在实际应用中，需要考虑如何避免二叉搜索树的退化，例如可以使用平衡二叉树等数据结构。

### code-golang

```Go
package main

import "fmt"

type Node struct {
	Key   int
	Left  *Node
	Right *Node
}

type BST struct {
	Root *Node
}

func (bst *BST) Insert(key int) {
	if bst.Root == nil {
		bst.Root = &Node{Key: key}
		return
	}

	currentNode := bst.Root
	for {
		if key < currentNode.Key {
			if currentNode.Left == nil {
				currentNode.Left = &Node{Key: key}
				return
			}
			currentNode = currentNode.Left
		} else {
			if currentNode.Right == nil {
				currentNode.Right = &Node{Key: key}
				return
			}
			currentNode = currentNode.Right
		}
	}
}

func (bst *BST) Search(key int) *Node {
	currentNode := bst.Root
	for currentNode != nil {
		if key == currentNode.Key {
			return currentNode
		}
		if key < currentNode.Key {
			currentNode = currentNode.Left
		} else {
			currentNode = currentNode.Right
		}
	}
	return nil
}

func (bst *BST) Delete(key int) bool {
	var parent *Node
	currentNode := bst.Root

	// 寻找要删除的节点
	for currentNode != nil && currentNode.Key != key {
		parent = currentNode
		if key < currentNode.Key {
			currentNode = currentNode.Left
		} else {
			currentNode = currentNode.Right
		}
	}

	// 没有找到要删除的节点
	if currentNode == nil {
		return false
	}

	// 要删除的节点有两个子节点
	if currentNode.Left != nil && currentNode.Right != nil {
		successor := currentNode.Right
		var successorParent *Node
		for successor.Left != nil {
			successorParent = successor
			successor = successor.Left
		}
		currentNode.Key = successor.Key
		if successorParent == nil {
			currentNode.Right = successor.Right
		} else {
			successorParent.Left = successor.Right
		}
		// 要删除的节点只有一个子节点
	} else if currentNode.Left != nil {
		if parent == nil {
			bst.Root = currentNode.Left
		} else if parent.Left == currentNode {
			parent.Left = currentNode.Left
		} else {
			parent.Right = currentNode.Left
		}
	} else if currentNode.Right != nil {
		if parent == nil {
			bst.Root = currentNode.Right
		} else if parent.Left == currentNode {
			parent.Left = currentNode.Right
		} else {
			parent.Right = currentNode.Right
		}
		// 要删除的节点是叶子节点
	} else {
		if parent == nil {
			bst.Root = nil
		} else if parent.Left == currentNode {
			parent.Left = nil
		} else {
			parent.Right = nil
		}
	}

	return true
}

func (bst *BST) InOrderTraversal(node *Node) {
	if node != nil {
		bst.InOrderTraversal(node.Left)
		fmt.Printf("%d ", node.Key)
		bst.InOrderTraversal(node.Right)
	}
}

func main() {
	bst := BST{}
	bst.Insert(8)
	bst.Insert(3)
	bst.Insert(1)
	bst.Insert(6)
	bst.Insert(10)
	bst.Insert(14)
	bst.Insert(4)
	bst.Insert(7)
	bst.Insert(13)

	fmt.Println(bst.Search(6))  // Output: &{6 <nil> 0xc00000a0d0}
	fmt.Println(bst.Search(11)) // Output: <nil>

	fmt.Println(bst.Delete(6))     // Output: true
	fmt.Println(bst.Search(6))     // Output: <nil>
	bst.InOrderTraversal(bst.Root) // Output: 1 3 4 6 7 8 10 13 14
}
```

### code-python

```Python
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def insert(self, key):
        if self.root is None:
            self.root = Node(key)
            return

        current_node = self.root
        while True:
            if key < current_node.key:
                if current_node.left is None:
                    current_node.left = Node(key)
                    return
                current_node = current_node.left
            else:
                if current_node.right is None:
                    current_node.right = Node(key)
                    return
                current_node = current_node.right

    def search(self, key):
        current_node = self.root
        while current_node is not None:
            if key == current_node.key:
                return current_node
            if key < current_node.key:
                current_node = current_node.left
            else:
                current_node = current_node.right
        return None

    def delete(self, key):
        parent_node = None
        current_node = self.root

        # 寻找要删除的节点
        while current_node is not None and current_node.key != key:
            parent_node = current_node
            if key < current_node.key:
                current_node = current_node.left
            else:
                current_node = current_node.right

        # 没有找到要删除的节点
        if current_node is None:
            return False

        # 要删除的节点有两个子节点
        if current_node.left is not None and current_node.right is not None:
            successor_node = current_node.right
            successor_parent_node = None
            while successor_node.left is not None:
                successor_parent_node = successor_node
                successor_node = successor_node.left
            current_node.key = successor_node.key
            if successor_parent_node is None:
                current_node.right = successor_node.right
            else:
                successor_parent_node.left = successor_node.right
        # 要删除的节点只有一个子节点
        elif current_node.left is not None:
            if parent_node is None:
                self.root = current_node.left
            elif parent_node.left == current_node:
                parent_node.left = current_node.left
            else:
                parent_node.right = current_node.left
        elif current_node.right is not None:
            if parent_node is None:
                self.root = current_node.right
            elif parent_node.left == current_node:
                parent_node.left = current_node.right
            else:
                parent_node.right = current_node.right
        # 要删除的节点是叶子节点
        else:
            if parent_node is None:
                self.root = None
            elif parent_node.left == current_node:
                parent_node.left = None
            else:
                parent_node.right = None

        return True

    def inorder_traversal(self, node=None, result=None):
        if node is None:
            node = self.root
        if result is None:
            result = []
        if node.left is not None:
            self.inorder_traversal(node.left, result)
        result.append(node.key)
        if node.right is not None:
            self.inorder_traversal(node.right, result)
        return result

if __name__ == '__main__':
    bst = BST()
    bst.insert(8)
    bst.insert(3)
    bst.insert(1)
    bst.insert(6)
    bst.insert(10)
    bst.insert(14)
    bst.insert(4)
    bst.insert(7)
    bst.insert(13)

    print(bst.search(6)) # Output: <__main__.Node object at 0x7f0b9e9f5b50>
    print(bst.search(11)) # Output: None

    print(bst.delete(6)) # Output: True
    print(bst.search(6)) # Output: None

    print(bst.inorder_traversal()) # Output: [1, 3, 4, 7, 8, 10, 13, 14]
```

## :point_right:AVL平衡二叉树 -- 细品

平衡二叉树（Balanced Binary Tree），也称为AVL树，是一种二叉搜索树，其左右子树的高度差不超过1，即任意节点的左右子树的高度差的绝对值不超过1。

平衡二叉树的一个重要特点是，它可以保证在最坏情况下，查找、插入和删除操作的时间复杂度都是O(log n)，其中n为节点数目。

```Bash
          5
        /   \
       2     7
      / \     \
     1   4     8
            /   \
           6     9
```

平衡二叉树的旋转操作有两种：

1. 左旋：将节点的右子树变为其父节点，同时节点成为其右子树的左子树。

```Bash
# 右树左旋
      a
       \
        b
         \
          c

      b
     / \
    a   c
```

1. 右旋：将节点的左子树变为其父节点，同时节点成为其左子树的右子树。

```Bash
# 左树右旋转
     c
     /
    b
   /
  a

      b
     / \
    a   c
```

### code-golang

```go
package main

import (
	"fmt"
)

type Node struct {
	key       int
	height    int
	leftNode  *Node
	rightNode *Node
}

func (node *Node) getHeight() int {
	if node == nil {
		return 0
	}
	return node.height
}

func (node *Node) updateHeight() {
	node.height = max(node.leftNode.getHeight(), node.rightNode.getHeight()) + 1
}

func (node *Node) getBalanceFactor() int {
	if node == nil {
		return 0
	}
	return node.leftNode.getHeight() - node.rightNode.getHeight()
}

func (node *Node) rightRotate() *Node {
	leftChild := node.leftNode
	rightGrandChild := leftChild.rightNode
	leftChild.rightNode = node
	node.leftNode = rightGrandChild
	node.updateHeight()
	leftChild.updateHeight()
	return leftChild
}

func (node *Node) leftRotate() *Node {
	rightChild := node.rightNode
	leftGrandChild := rightChild.leftNode
	rightChild.leftNode = node
	node.rightNode = leftGrandChild
	node.updateHeight()
	rightChild.updateHeight()
	return rightChild
}

func (node *Node) insert(key int) *Node {
	if node == nil {
		return &Node{key: key, height: 1}
	}
	if key < node.key {
		node.leftNode = node.leftNode.insert(key)
	} else if key > node.key {
		node.rightNode = node.rightNode.insert(key)
	} else {
		return node
	}
	node.updateHeight()
	balanceFactor := node.getBalanceFactor()
	if balanceFactor > 1 {
		if node.leftNode.getBalanceFactor() < 0 {
			node.leftNode = node.leftNode.leftRotate()
		}
		return node.rightRotate()
	} else if balanceFactor < -1 {
		if node.rightNode.getBalanceFactor() > 0 {
			node.rightNode = node.rightNode.rightRotate()
		}
		return node.leftRotate()
	}
	return node
}

func (node *Node) findMinValueNode() *Node {
	current := node
	for current.leftNode != nil {
		current = current.leftNode
	}
	return current
}

func (node *Node) delete(key int) *Node {
	if node == nil {
		return node
	}
	if key < node.key {
		node.leftNode = node.leftNode.delete(key)
	} else if key > node.key {
		node.rightNode = node.rightNode.delete(key)
	} else {
		if node.leftNode == nil || node.rightNode == nil {
			var temp *Node
			if node.leftNode != nil {
				temp = node.leftNode
			} else {
				temp = node.rightNode
			}
			if temp == nil {
				node = nil
			} else {
				*node = *temp
			}
		} else {
			temp := node.rightNode.findMinValueNode()
			node.key = temp.key
			node.rightNode = node.rightNode.delete(temp.key)
		}
	}
	if node == nil {
		return node
	}
	node.updateHeight()
	balanceFactor := node.getBalanceFactor()
	if balanceFactor > 1 {
		if node.leftNode.getBalanceFactor() < 0 {
			node.leftNode = node.leftNode.leftRotate()
		}
		return node.rightRotate()
	} else if balanceFactor < -1 {
		if node.rightNode.getBalanceFactor() > 0 {
			node.rightNode = node.rightNode.rightRotate()
		}
		return node.leftRotate()
	}
	return node
}

func (node *Node) search(key int) *Node {
	if node == nil || node.key == key {
		return node
	}
	if key < node.key {
		return node.leftNode.search(key)
	}
	return node.rightNode.search(key)
}

func (node *Node) inOrderTraversal() {
	if node == nil {
		return
	}
	node.leftNode.inOrderTraversal()
	fmt.Printf("%d ", node.key)
	node.rightNode.inOrderTraversal()
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

type AVLTree struct {
	root *Node
}

func (tree *AVLTree) Insert(key int) {
	tree.root = tree.root.insert(key)
}

func (tree *AVLTree) Delete(key int) {
	tree.root = tree.root.delete(key)
}

func (tree *AVLTree) Search(key int) *Node {
	return tree.root.search(key)
}

func (tree *AVLTree) InOrderTraversal() {
	tree.root.inOrderTraversal()
}

func main() {
	tree := &AVLTree{}
	tree.Insert(8)
	tree.Insert(3)
	tree.Insert(1)
	tree.Insert(6)
	tree.Insert(10)
	tree.Insert(14)
	tree.Insert(4)
	tree.Insert(7)
	tree.Insert(13)
	fmt.Print("Inorder traversal: ")
	tree.InOrderTraversal() // Output: Inorder traversal: 1 3 4 7 8 10 13 14
	fmt.Println()
	fmt.Println(tree.Search(6))  // Output: &{6 1 0xc000012180 0xc0000121a0}
	fmt.Println(tree.Search(11)) // Output: <nil>
	tree.Delete(6)
	fmt.Println(tree.Search(6)) // Output: <nil>
}
```

### code-python

```python
class Node:
    def __init__(self, key):
        self.key = key
        self.height = 1
        self.left_node = None
        self.right_node = None

class AVLTree:
    def __init__(self):
        self.root = None

    def get_height(self, node):
        if node is None:
            return 0
        return node.height

    def update_height(self, node):
        node.height = max(self.get_height(node.left_node), self.get_height(node.right_node)) + 1

    def get_balance_factor(self, node):
        if node is None:
            return 0
        return self.get_height(node.left_node) - self.get_height(node.right_node)

    def right_rotate(self, node):
        left_child = node.left_node
        right_grand_child = left_child.right_node
        left_child.right_node = node
        node.left_node = right_grand_child
        self.update_height(node)
        self.update_height(left_child)
        return left_child

    def left_rotate(self, node):
        right_child = node.right_node
        left_grand_child = right_child.left_node
        right_child.left_node = node
        node.right_node = left_grand_child
        self.update_height(node)
        self.update_height(right_child)
        return right_child

    def insert(self, node, key):
        if node is None:
            return Node(key)
        elif key < node.key:
            node.left_node = self.insert(node.left_node, key)
        elif key > node.key:
            node.right_node = self.insert(node.right_node, key)
        else:
            return node

        self.update_height(node)
        balance_factor = self.get_balance_factor(node)

        if balance_factor > 1:
            if self.get_balance_factor(node.left_node) < 0:
                node.left_node = self.left_rotate(node.left_node)
            return self.right_rotate(node)
        elif balance_factor < -1:
            if self.get_balance_factor(node.right_node) > 0:
                node.right_node = self.right_rotate(node.right_node)
            return self.left_rotate(node)
        return node

    def find_min_value_node(self, node):
        current = node
        while current.left_node is not None:
            current = current.left_node
        return current

    def delete(self, node, key):
        if node is None:
            return node
        elif key < node.key:
            node.left_node = self.delete(node.left_node, key)
        elif key > node.key:
            node.right_node = self.delete(node.right_node, key)
        else:
            if node.left_node is None:
                temp = node.right_node
                node = None
                return temp
            elif node.right_node is None:
                temp = node.left_node
                node = None
                return temp
            temp = self.find_min_value_node(node.right_node)
            node.key = temp.key
            node.right_node = self.delete(node.right_node, temp.key)

        if node is None:
            return node

        self.update_height(node)
        balance_factor = self.get_balance_factor(node)

        if balance_factor > 1:
            if self.get_balance_factor(node.left_node) < 0:
                node.left_node = self.left_rotate(node.left_node)
            return self.right_rotate(node)
        elif balance_factor < -1:
            if self.get_balance_factor(node.right_node) > 0:
                node.right_node = self.right_rotate(node.right_node)
            return self.left_rotate(node)
        return node

    def search(self, node, key):
        if node is None or node.key == key:
            return node
        elif key < node.key:
            return self.search(node.left_node, key)
        else:
            return self.search(node.right_node, key)

    def in_order_traversal(self, node):
        if node is None:
            return
        self.in_order_traversal(node.left_node)
        print(node.key, end=" ")
        self.in_order_traversal(node.right_node)

    def insert_key(self, key):
        self.root = self.insert(self.root, key)

    def delete_key(self, key):
        self.root = self.delete(self.root, key)

    def search_key(self, key):
        return self.search(self.root, key)

    def in_order_traversal_tree(self):
        self.in_order_traversal(self.root)

if __name__ == '__main__':
    tree = AVLTree()
    tree.insert_key(8)
    tree.insert_key(3)
    tree.insert_key(1)
    tree.insert_key(6)
    tree.insert_key(10)
    tree.insert_key(14)
    tree.insert_key(4)
    tree.insert_key(7)
    tree.insert_key(13)
    print("Inorder traversal:", end=" ")
    tree.in_order_traversal_tree() # Output: Inorder traversal: 1 3 4 6 7 8 10 13 14
    print()
    print(tree.search_key(6)) # Output: <__main__.Node object at 0x7f1e9c80f2e0>
    print(tree.search_key(11)) # Output: None
    tree.delete_key(6)
    print(tree.search_key(6)) # Output: None
```

## :point_right:红黑树

红黑树（Red-Black Tree）是一种自平衡二叉搜索树，它的每个节点上都带有一个存储位表示节点的颜色，可以是红色或黑色。

红黑树的每个节点都满足以下性质：

1. 节点是红色或黑色。
2. 根节点是黑色。
3. 每个叶子节点（NIL节点，空节点）是黑色的。
4. 如果一个节点是红色的，则它的两个子节点都是黑色的。
5. 对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点。

![img](./images/red-black.png)

红黑树的性质保证了它的最长路径不会超过最短路径的两倍，因此红黑树的查找、插入和删除操作的时间复杂度都是O(log n)，其中n为节点数目。

### code-golang

```go
package main

import "fmt"

const (
	red   = true
	black = false
)

type Node struct {
	key         int
	value       interface{}
	left, right *Node
	color       bool
}

func isRed(node *Node) bool {
	if node == nil {
		return false
	}
	return node.color == red
}

func rotateLeft(node *Node) *Node {
	x := node.right
	node.right = x.left
	x.left = node
	x.color = node.color
	node.color = red
	return x
}

func rotateRight(node *Node) *Node {
	x := node.left
	node.left = x.right
	x.right = node
	x.color = node.color
	node.color = red
	return x
}

func flipColors(node *Node) {
	node.color = red
	node.left.color = black
	node.right.color = black
}

func Put(root *Node, key int, value interface{}) *Node {
	if root == nil {
		return &Node{key: key, value: value, color: red}
	}

	if key < root.key {
		root.left = Put(root.left, key, value)
	} else if key > root.key {
		root.right = Put(root.right, key, value)
	} else {
		root.value = value
	}

	if isRed(root.right) && !isRed(root.left) {
		root = rotateLeft(root)
	}
	if isRed(root.left) && isRed(root.left.left) {
		root = rotateRight(root)
	}
	if isRed(root.left) && isRed(root.right) {
		flipColors(root)
	}

	return root
}

func Get(root *Node, key int) interface{} {
	for root != nil {
		if key < root.key {
			root = root.left
		} else if key > root.key {
			root = root.right
		} else {
			return root.value
		}
	}
	return nil
}

func Min(root *Node) *Node {
	if root == nil {
		return nil
	}
	if root.left == nil {
		return root
	}
	return Min(root.left)
}

func deleteMin(root *Node) *Node {
	if root.left == nil {
		return root.right
	}
	root.left = deleteMin(root.left)
	return root
}

func Delete(root *Node, key int) *Node {
	if root == nil {
		return nil
	}

	if key < root.key {
		root.left = Delete(root.left, key)
	} else if key > root.key {
		root.right = Delete(root.right, key)
	} else {
		if root.right == nil {
			return root.left
		}
		if root.left == nil {
			return root.right
		}
		t := root
		root = Min(t.right)
		root.right = deleteMin(t.right)
		root.left = t.left
	}

	if isRed(root.right) && !isRed(root.left) {
		root = rotateLeft(root)
	}
	if isRed(root.left) && isRed(root.left.left) {
		root = rotateRight(root)
	}
	if isRed(root.left) && isRed(root.right) {
		flipColors(root)
	}

	return root
}

func InOrderTraversal(root *Node) {
	if root == nil {
		return
	}
	InOrderTraversal(root.left)
	fmt.Printf("%d ", root.key)
	InOrderTraversal(root.right)
}

func main() {
	var root *Node
	root = Put(root, 5, "five")
	root = Put(root, 1, "one")
	root = Put(root, 8, "eight")
	root = Put(root, 3, "three")
	root = Put(root, 6, "six")
	root = Put(root, 9, "nine")
	fmt.Print("In-order traversal: ")
	InOrderTraversal(root)
	fmt.Println()

	fmt.Println("Value of key 5:", Get(root, 5))
	fmt.Println("Value of key 10:", Get(root, 10))

	root = Delete(root, 3)
	fmt.Print("In-order traversal after deleting key 3: ")
	InOrderTraversal(root)
	fmt.Println()
}
```

### code-python

```bash
class Node:
    def __init__(self, key, value, color):
        self.key = key
        self.value = value
        self.left = None
        self.right = None
        self.color = color

class RedBlackTree:
    def __init__(self):
        self.root = None

    def is_red(self, node):
        return node is not None and node.color == 'red'

    def rotate_left(self, node):
        x = node.right
        node.right = x.left
        x.left = node
        x.color = node.color
        node.color = 'red'
        return x

    def rotate_right(self, node):
        x = node.left
        node.left = x.right
        x.right = node
        x.color = node.color
        node.color = 'red'
        return x

    def flip_colors(self, node):
        node.color = 'red'
        node.left.color = 'black'
        node.right.color = 'black'

    def put(self, key, value):
        self.root = self._put(self.root, key, value)

    def _put(self, node, key, value):
        if node is None:
            return Node(key, value, 'red')
        if key < node.key:
            node.left = self._put(node.left, key, value)
        elif key > node.key:
            node.right = self._put(node.right, key, value)
        else:
            node.value = value

        if self.is_red(node.right) and not self.is_red(node.left):
            node = self.rotate_left(node)
        if self.is_red(node.left) and self.is_red(node.left.left):
            node = self.rotate_right(node)
        if self.is_red(node.left) and self.is_red(node.right):
            self.flip_colors(node)

        return node

    def get(self, key):
        node = self.root
        while node is not None:
            if key < node.key:
                node = node.left
            elif key > node.key:
                node = node.right
            else:
                return node.value
        return None

    def min_node(self, node):
        while node.left is not None:
            node = node.left
        return node

    def delete_min(self):
        if not self.is_red(self.root.left) and not self.is_red(self.root.right):
            self.root.color = 'red'
        self.root = self._delete_min(self.root)

    def _delete_min(self, node):
        if node.left is None:
            return None
        if not self.is_red(node.left) and not self.is_red(node.left.left):
            node = self.move_red_left(node)
        node.left = self._delete_min(node.left)
        return self.balance(node)

    def delete(self, key):
        if not self.is_red(self.root.left) and not self.is_red(self.root.right):
            self.root.color = 'red'
        self.root = self._delete(self.root, key)

    def _delete(self, node, key):
        if key < node.key:
            if not self.is_red(node.left) and not self.is_red(node.left.left):
                node = self.move_red_left(node)
            node.left = self._delete(node.left, key)
        else:
            if self.is_red(node.left):
                node = self.rotate_right(node)
            if key == node.key and node.right is None:
                return None
            if not self.is_red(node.right) and not self.is_red(node.right.left):
                node = self.move_red_right(node)
            if key == node.key:
                x = self.min_node(node.right)
                node.key = x.key
                node.value = x.value
                node.right = self._delete_min(node.right)
            else:
                node.right = self._delete(node.right, key)
        return self.balance(node)

    def move_red_left(self, node):
        self.flip_colors(node)
        if self.is_red(node.right.left):
            node.right = self.rotate_right(node.right)
            node = self.rotate_left(node)
            self.flip_colors(node)
        return node

    def move_red_right(self, node):
        self.flip_colors(node)
        if self.is_red(node.left.left):
            node = self.rotate_right(node)
            self.flip_colors(node)
        return node

    def balance(self, node):
        if self.is_red(node.right):
            node = self.rotate_left(node)
        if self.is_red(node.left) and self.is_red(node.left.left):
            node = self.rotate_right(node)
        if self.is_red(node.left) and self.is_red(node.right):
            self.flip_colors(node)
        return node

    def in_order_traversal(self, node):
        if node is None:
            return
        self.in_order_traversal(node.left)
        print(node.key, node.color)
        self.in_order_traversal(node.right)

tree = RedBlackTree()
tree.put(5, 'five')
tree.put(1, 'one')
tree.put(8, 'eight')
tree.put(3, 'three')
tree.put(6, 'six')
tree.put(9, 'nine')
print('In-order traversal:')
tree.in_order_traversal(tree.root)

print('Value of key 5:', tree.get(5))
print('Value of key 10:', tree.get(10))

tree.delete(3)
print('In-order traversal after deleting key 3:')
tree.in_order_traversal(tree.root)
```

## :point_right:B树

B树（Balance-tree）是一种自平衡的多路搜索树，常用于实现数据库和文件系统等数据存储系统中的索引结构。

B树将数据存储在节点上而非叶子节点上，每个节点可以存储多个关键字和指向子节点的指针。

一棵B树的基本特征如下：

1. 每个节点最多有m个子节点。
2. 除根节点和叶子节点外，每个节点至少有ceil(m/2)个子节点。
3. 所有的叶子节点都在同一层。
4. 每个节点中的关键字按照从小到大的顺序排序。

![img](./images/Btree.png)

### code-golang

> 谷歌例子：https://github.com/google/btree
>
> tidwall：https://github.com/tidwall/btree

```golang
package main

import (
	"fmt"
)

type BTree struct {
	root *BNode
	t    int
}

type BNode struct {
	keys     []string
	children []*BNode
	leaf     bool
	n        int
}

func (t *BTree) Search(k string) *BNode {
	return t.search(t.root, k)
}

func (t *BTree) search(node *BNode, k string) *BNode {
	i := 0
	for i < node.n && k > node.keys[i] {
		i++
	}
	if i < node.n && k == node.keys[i] {
		return node
	}
	if node.leaf {
		return nil
	}
	return t.search(node.children[i], k)
}

func (t *BTree) Insert(k string) {
	if t.root == nil {
		t.root = &BNode{keys: []string{k}, children: []*BNode{}, leaf: true, n: 1}
		return
	}

	if len(t.root.keys) == 2*t.t-1 {
		oldRoot := t.root
		t.root = &BNode{keys: []string{}, children: []*BNode{oldRoot}, leaf: false, n: 0}
		t.split(oldRoot, 0)
		t.insertNonfull(t.root, k)
	} else {
		t.insertNonfull(t.root, k)
	}
}

func (t *BTree) split(node *BNode, i int) {
	child := node.children[i]
	newChild := &BNode{keys: []string{}, children: []*BNode{}, leaf: child.leaf, n: t.t - 1}
	for j := 0; j < t.t-1; j++ {
		newChild.keys = append(newChild.keys, child.keys[j+t.t])
	}
	if !child.leaf {
		for j := 0; j < t.t; j++ {
			newChild.children = append(newChild.children, child.children[j+t.t])
		}
	}
	child.keys = child.keys[0 : t.t-1]
	child.children = child.children[0:t.t]
	node.children = append(node.children, nil)
	for j := node.n; j > i; j-- {
		node.children[j] = node.children[j-1]
		node.keys[j] = node.keys[j-1]
	}
	node.children[i+1] = newChild
	node.keys[i] = child.keys[t.t-1]
	node.n++
}

func (t *BTree) insertNonfull(node *BNode, k string) {
	i := node.n - 1
	if node.leaf {
		node.keys = append(node.keys, "")
		for i >= 0 && k < node.keys[i] {
			node.keys[i+1] = node.keys[i]
			i--
		}
		node.keys[i+1] = k
		node.n++
	} else {
		for i >= 0 && k < node.keys[i] {
			i--
		}
		i++
		if len(node.children[i].keys) == 2*t.t-1 {
			t.split(node, i)
			if k > node.keys[i] {
				i++
			}
		}
		t.insertNonfull(node.children[i], k)
	}
}

func (t *BTree) Delete(k string) {
	if t.root == nil {
		return
	}
	t.delete(t.root, k)
	if len(t.root.keys) == 0 {
		t.root = t.root.children[0]
	}
}

func (t *BTree) delete(node *BNode, k string) {
	i := 0
	for i < node.n && k > node.keys[i] {
		i++
	}
	if i < node.n && k == node.keys[i] {
		if node.leaf {
			node.keys = append(node.keys[0:i], node.keys[i+1:]...)
			node.n--
		} else {
			if len(node.children[i].keys) >= t.t {
				pred := t.getPredecessor(node.children[i])
				node.keys[i] = pred
				t.delete(node.children[i], pred)
			} else if len(node.children[i+1].keys) >= t.t {
				succ := t.getSuccessor(node.children[i+1])
				node.keys[i] = succ
				t.delete(node.children[i+1], succ)
			} else {
				t.merge(node, i)
				t.delete(node.children[i], k)
			}
		}
	} else {
		if node.leaf {
			return
		}
		if len(node.children[i].keys) < t.t {
			if i > 0 && len(node.children[i-1].keys) >= t.t {
				t.borrowFromPrev(node, i)
			} else if i < node.n && len(node.children[i+1].keys) >= t.t {
				t.borrowFromNext(node, i)
			} else if i > 0 {
				t.merge(node, i-1)
			} else {
				t.merge(node, i)
			}
		}
		t.delete(node.children[i], k)
	}
}

func (t *BTree) getPredecessor(node *BNode) string {
	for !node.leaf {
		node = node.children[len(node.children)-1]
	}
	return node.keys[len(node.keys)-1]
}

func (t *BTree) getSuccessor(node *BNode) string {
	for !node.leaf {
		node = node.children[0]
	}
	return node.keys[0]
}

func (t *BTree) borrowFromPrev(node *BNode, i int) {
	child := node.children[i]
	sibling := node.children[i-1]
	child.keys = append([]string{sibling.keys[len(sibling.keys)-1]}, child.keys...)
	if !child.leaf {
		child.children = append([]*BNode{sibling.children[len(sibling.children)-1]}, child.children...)
	}
	node.keys[i-1] = sibling.keys[len(sibling.keys)-2]
	sibling.keys = sibling.keys[0 : len(sibling.keys)-1]
	if !sibling.leaf {
		sibling.children = sibling.children[0 : len(sibling.children)-1]
	}
}

func (t *BTree) borrowFromNext(node *BNode, i int) {
	child := node.children[i]
	sibling := node.children[i+1]
	child.keys = append(child.keys, sibling.keys[0])
	if !child.leaf {
		child.children = append(child.children, sibling.children[0])
	}
	node.keys[i] = sibling.keys[0]
	sibling.keys = sibling.keys[1:]
	if !sibling.leaf {
		sibling.children = sibling.children[1:]
	}
}

func (t *BTree) merge(node *BNode, i int) {
	child := node.children[i]
	sibling := node.children[i+1]
	child.keys = append(child.keys, node.keys[i])
	child.keys = append(child.keys, sibling.keys...)
	if !child.leaf {
		child.children = append(child.children, sibling.children...)
	}
	node.keys = append(node.keys[0:i], node.keys[i+1:]...)
	node.children = append(node.children[0:i+1], node.children[i+2:]...)
	node.n--
}

func main() {
	t := &BTree{t: 2}
	t.Insert("hello")
	t.Insert("world")
	fmt.Println(t.Search("hello")) // output: &{[hello] []*BNode true 1}
	t.Delete("hello")
	fmt.Println(t.Search("hello")) // output: <nil>
}
```

### code-python

```python
class BTreeNode:
	def __init__(self, order, values=None):
		self.order = order
		self.separators = []
		self.values = []
		self.children = []
		self.parent = None
		self.is_root = None
		if values:
			self.set_values(values)


	def search(self, key):

		separator_to_follow = self.separators[-1] # Initialize with last separator,

		for i, (k, v) in enumerate(self.values):
			if key < k:
				separator_to_follow = i           # Because if not found until the end, must be last.
				break
			elif key == k:
				return v
		if self.is_leaf():
			return None # Key not found
		else:
			return self.children[separator_to_follow].search(key)

	def set_values(self, values):
		self.values = values
		if not self.separators or self.separators[-1] != len(values):
			self.separators = range(len(values) + 1)


	def get_successor(self, key):

		for i, (k, v) in enumerate(self.values):
			if key < k:
				if self.is_leaf():
					return (k, v)
				else:
					return self.children[i].get_successor(key)
			elif key == k:
				if self.is_leaf():
					raise Exception("Something wrong - should not need to find sucessor of leaf node.")
				else:
					return self.children[i+1].get_successor(key)

		return self.children[-1].get_successor(key) #must be last


	def set_children(self, children):
		self.children = children
		if children:
			self.separators = range(len(children))
		else:
			self.separators = range(len(self.values) + 1)

	# Inserts value into node ignoring restrictions
	def insert_to_values(self, (key, value), index=None):


		if not self.values:
			self.set_values([(key, value)])
		else:
			if not index:
				index = self.separators[-1] # Initialize with last separator,
				for i, (k, v) in enumerate(self.values):
					if key < k:
						index = i           # Because if not found until the end, must be last.
						break

			self.values.insert(index, (key, value))
			self.separators = range(len(self.values)+1) # Just add one new separator


	# Puts (k2, v2) in the place of (k1, v1)
	def substitute_value(self, (k1, v1), (k2, v2)):

		for i, (k, v) in enumerate(self.values):

			if k == k1:
				self.values[i] = (k2, v2)
				return
			elif k > k1:
				self.children[i].substitute_value((k1, v1), (k2, v2))
				return


		return self.children[-1].substitute_value((k1, v1), (k2, v2))

	# Walks all the way down to leafs, restructuring over-filled nodes along the way, and then inserts.
	def insert(self, (key, value)):

		if not self.values:
			self.insert_to_values((key, value))
		else:
			assert self.separators[-1] == len(self.values), "%s %s" %( self.values , self.separators)
			if self.is_overflowing():
				if self.is_root:
					self.create_new_root()
				self.split()
				self.parent.insert((key, value))
			else:
				separator_to_insert = self.separators[-1] # Initialize with last separator,
				for i, (k, v) in enumerate(self.values):
					if key < k:
						separator_to_insert = i           # Because if not found until the end, must be last.
						break
				if self.is_leaf():
					self.insert_to_values((key, value), separator_to_insert)
				else:
					return self.children[separator_to_insert].insert((key, value))



	# Removes keys ignoring rebalancing rules - assumes it was already done
	def remove_from_values(self, key):

		for i, (k, v) in enumerate(self.values):

			if k == key:
				self.values.pop(i)
				self.separators.pop()
				return
			elif k > key:

				self.children[i].remove_from_values(key)
				return
		return self.children[-1].remove_from_values(key)

	def split(self):

		# Moves median up
		self.parent.insert_to_values(self.values[len(self.values)/2])
		key_gone_up = self.values[len(self.values)/2][0]
		del self.values[len(self.values)/2]
		self.separators.pop()

		new_right_child = BTreeNode(self.order)
		new_right_child.parent = self.parent
		new_right_child.set_values(self.values[len(self.values)/2:])
		new_right_child.set_children(self.children[len(self.children)/2:])
		for c in new_right_child.children:
			c.parent = new_right_child

		self.set_values(self.values[:len(self.values)/2])	#Current node becomes new left node
		self.set_children(self.children[:len(self.children)/2])

		if self.parent.children:
			index_of_new_child = self.parent.separators[-1]
			for i, c in enumerate(self.parent.children):
				if c == self:
					index_of_new_child = i + 1
					break

			self.parent.children.insert(index_of_new_child, new_right_child)
			self.parent.separators = range(len(self.parent.values) + 1)

		else:
			self.parent.set_children([self, new_right_child])

	#Splits current root into two subtrees, and set them to be children of a new root
	def create_new_root(self):

		self.is_root = False
		self.parent = BTreeNode(self.order)
		self.parent.is_root = True

	def remove(self, key):

		if (not self.is_root) and self.is_underflowing(): # First get balacing right, later remove desired key
			if not self.stole_key_from_sibling():
				self.fuse_with_sibling()
			if self.parent:
				self.parent.remove(key)
			else:
				self.remove(key)
			return
		else:

			for i, (k, v) in enumerate(self.values):
				if k == key:
					if self.is_leaf():
						self.remove_from_values(key)
						return
					else:
						successor = self.get_successor(key)
						self.remove(successor[0])
						self.substitute_value((k, v), successor)
						return
				elif k > key:
					return self.children[i].remove(key)


			return self.children[-1].remove(key) # Must be last


	def fuse_with_sibling(self):

		left_sibling, right_sibling = self.get_siblings()

		if right_sibling: #Fuse self with right sibling, pulling down one parent key
			for i, c in enumerate(self.parent.children):
				if c == self:
					index_to_pull_down, key_to_pull_down = i+1, self.parent.values.pop(i)
					break

			self.values.append(key_to_pull_down)

			for v in right_sibling.values:
				self.values.append(v)

			for c in right_sibling.children:
				c.parent = self
				self.children.append(c)

			self.parent.children.pop(index_to_pull_down)
			self.parent.separators.pop()

			self.separators = range(len(self.values) + 1)


		elif left_sibling: #Fuse left sibling with self, pulling down one parent key
			for i, c in enumerate(self.parent.children):
				if c == self:
					index_to_pull_down, key_to_pull_down = i-1, self.parent.values.pop(i-1)
					break

			self.values.insert(0, key_to_pull_down)

			for v in list(reversed(left_sibling.values)):
				self.values.insert(0, v)

			for c in list(reversed(left_sibling.children)):
				c.parent = self
				self.children.insert(0, c)

			self.parent.children.pop(index_to_pull_down)
			self.parent.separators.pop()

			self.separators = range(len(self.values) + 1)


		if self.parent.is_root and len(self.parent.values)==0: # Tree decreases its height
			self.is_root = True
			self.parent.is_root = False
			self.parent = None


	# Returns true if its posible to steal a key from either a left or a right sibling. Otherwise, returns false.
	def stole_key_from_sibling(self):

		left_sibling, right_sibling = self.get_siblings()



		if left_sibling and not left_sibling.is_underflowing():

			#right rotation
			left_sibling_last_key, left_sibling_last_child = left_sibling.values.pop(), left_sibling.children.pop() if left_sibling.children else None
			left_sibling.separators.pop()

			for i, c in enumerate(self.parent.children):
				if id(c) == id(self):
					parent_index_to_go_down = i - 1
					break
			new_value = self.parent.values.pop(parent_index_to_go_down)


			self.values.insert(0, new_value)
			self.parent.values.insert(parent_index_to_go_down, left_sibling_last_key)


			self.separators = range(len(self.values) + 1)


			if left_sibling_last_child:
				left_sibling_last_child.parent = self
				self.children.insert(0, left_sibling_last_child)

			return True

		elif right_sibling and not right_sibling.is_underflowing():

			# left rotation
			right_sibling_first_key, right_sibling_first_child = right_sibling.values.pop(0), right_sibling.children.pop(0) if right_sibling.children else None
			right_sibling.separators.pop()

			for i, c in enumerate(self.parent.children):
				if id(c) == id(self):
					parent_index_to_go_down = i
					break

			new_value = self.parent.values.pop(parent_index_to_go_down)
			self.values.append(new_value)
			self.parent.values.insert(parent_index_to_go_down, right_sibling_first_key)
			self.separators = range(len(self.values) + 1)

			if right_sibling_first_child:
				right_sibling_first_child.parent = self
				self.children.append(right_sibling_first_child)

			return True

		return False

	def get_siblings(self):

		for i, c in enumerate(self.parent.children):
			if c == self:
				if i == 0:
					return None, self.parent.children[i+1]
				elif i == len(self.parent.children) - 1:
					return self.parent.children[i-1], None
				else:
					return self.parent.children[i-1], self.parent.children[i+1]

		return None, None

	def is_underflowing(self):
		return len(self.separators) == self.order/2

	def is_overflowing(self):
		return len(self.separators) == self.order


	def is_leaf(self):
		return not bool(self.children)



'''
	Implements an order M BTree.
	Each node will have between (M-1)/2 and M-1 values (included). Each value is a tuple (key, entry).
	All leafs are at the same depth. Search, insertion and deletion can be done in logarithmic time.
'''

class BTree:

	def __init__(self, order):
		self.order = order
		self.root = None

	def search(self, key):
		return self.root.search(key)

	def insert(self, (key, value)):

		if not self.root:
			self.root = BTreeNode(self.order)
			self.root.is_root = True

		self.root.insert((key, value)) # Try to insert at the root, then go all the way down adjusting over-filled nodes

		if not self.root.is_root:
			self.root = self.root.parent

	def remove(self, key):

		if not self.root:
			return False

		self.root.remove(key)

		if not self.root.is_root:
			self.root = self.root.children[0]



''' 
	Everything below here is not needed, it is used only for testing purposes.
'''

import matplotlib.pyplot as pp
import time
from random import shuffle	

orders_to_test = range(0, 1024, 16)
number_of_operations = 10**2

search_avg_times = []
insertion_avg_times = []
deletion_avg_times = []

for order in orders_to_test:

	BT = BTree(order)

	values_to_test = range(number_of_operations)
	shuffle(values_to_test)

	start_time = time.clock()
	for i in values_to_test:
		BT.insert((i, {"testdata":i}))
	end_time = time.clock()

	average_time = float(end_time - start_time)/number_of_operations
	insertion_avg_times.append(average_time*10**6)
	
	shuffle(values_to_test)

	start_time = time.clock()
	for i in values_to_test:
		BT.search(i)

	end_time = time.clock()

	average_time = (end_time - start_time)/number_of_operations

	search_avg_times.append(average_time*10**6)

	shuffle(values_to_test)

	start_time = time.clock()
	for i in values_to_test:
		BT.remove(i)

	end_time = time.clock()

	average_time = (end_time - start_time)/number_of_operations

	deletion_avg_times.append(average_time*10**6)


pp.subplot(1, 3, 1)
pp.title("Insertion time")
pp.xlabel("BTree Order")
pp.ylabel(u"Average time (µs)")

pp.scatter(orders_to_test, insertion_avg_times)
pp.subplot(1, 3, 2)
pp.title("Search time")
pp.xlabel("BTree Order")
pp.ylabel(u"Average time (µs)")

pp.scatter(orders_to_test, search_avg_times)
pp.subplot(1, 3, 3)
pp.title("Deletion time")
pp.xlabel("BTree Order")
pp.ylabel(u"Average time (µs)")
pp.scatter(orders_to_test, deletion_avg_times)
pp.show()
```

## B+树

B+树是B-树的变体，也是一种多路搜索树, 它与 B- 树的不同之处在于:

1. 所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)
2. 为所有叶子结点增加了一个链指针

![img](./images/B+tree.png)

### code-golang

### code-python

# :point_right:二叉树遍历

- `前序遍历`: 按照“根节点-左子树-右子树”的顺序遍历二叉树。
- `中序遍历`: 按照“左子树-根节点-右子树”的顺序遍历二叉树。
- `后续遍历`: 按照“左子树-右子树-根节点”的顺序遍历二叉树。
- `层序遍历`: 层序遍历是一种广度优先搜索（BFS）的应用，它遍历二叉树的每一层节点，从上到下、从左到右依次访问。

### :point_right:code-golang

```Go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

// preorderTraveral 前序遍历
// 根结点-左节点-右节点
func preorderTraversal(node *TreeNode) {
    if node == nil {
        return
    }
    fmt.Println(node.Val)
    preorderTraversal(node.Left)
    preorderTraversal(node.Right)
}

// inorderTraversal 中序遍历
// 左节点-根结点-右节点
func inorderTraversal(node *TreeNode) {
    if node == nil {
        return
    }
    inorderTraversal(node.Left)
    fmt.Println(node.Val)
    inorderTraversal(node.Right)
}

// postorderTraversal 后续遍历
// 左节点-右节点-根结点
func postorderTraversal(node *TreeNode) {
    if node == nil {
        return
    }
    postorderTraversal(node.Left)
    postorderTraversal(node.Right)
    fmt.Println(node.Val)
}

// BFS 实现
// sequenceTraversalBFS 层序遍历.
// 层序遍历是一种广度优先搜索（BFS）的应用，它遍历二叉树的每一层节点，从上到下、从左到右依次访问。
func sequenceTraversalBFS(node *TreeNode) {
    if node == nil {
        return
    }
    // queue treenode队列
    queue := []*TreeNode{node}
    for len(queue) > 0 {
        // 遍历当前
        for l := len(queue); l > 0; l-- {
            if queue[0].Left != nil {
                queue = append(queue, queue[0].Left)
            }

            if queue[0].Right != nil {
                queue = append(queue, queue[0].Right)
            }
            fmt.Println(queue[0].Val)

            // 剔除当前元素
            queue = queue[1:]
        }
    }
}

func main() {
    tn := &TreeNode{
        Val: 1,
        Left: &TreeNode{
            Val: 2,
            Left: &TreeNode{
                Val: 4,
            },
            Right: &TreeNode{
                Val: 5,
            },
        },
        Right: &TreeNode{
            Val: 3,
            Left: &TreeNode{
                Val: 6,
            },
            Right: &TreeNode{
                Val: 7,
            },
        },
    }
    preorderTraversal(tn) // 1245367
    inorderTraversal(tn)  // 4251637
    postorderTraversal(tn) // 4526731
    sequenceTraversalBFS(tn)  // 1234567
}
```

### :point_right:code-python

```Python
class TreeNode(object):
    def __init__(self, val: int, left=None, right=None) -> None:
        self.Val = val
        self.Left = left
        self.Right = right

def preorder_traversal(node: TreeNode):
    """
    preorder_traversal 前序遍历.
    根结点-左节点-右节点
    """
    if not node:
        return

    print(node.Val)
    preorder_traversal(node.Left)
    preorder_traversal(node.Right)

def inorder_traversal(node: TreeNode):
    """
    inorder_traversal 中序遍历
    左节点-根节点-右节点
    """
    if not node:
        return

    inorder_traversal(node.Left)
    print(node.Val)
    inorder_traversal(node.Right)

def postorder_traversal(node: TreeNode):
    """
    postorder_traversal 后续序遍历
    左节点-右节点-根节点
    """
    if not node:
        return

    postorder_traversal(node.Left)
    postorder_traversal(node.Right)
    print(node.Val)

def sequence_traversalBFS(node: TreeNode):
    """
    sequence_traversalBFS 层序遍历.
    层序遍历是一种广度优先搜索（BFS）的应用，它遍历二叉树的每一层节点，从上到下、从左到右依次访问。
    """
    if not node:
        return

    # que TreeNode队列
    queue: list[node] = [node]
    while len(queue) > 0:
        for _ in range(0, len(queue)):
            if queue[0].Left:
                queue.append(queue[0].Left)
            if queue[0].Right:
                queue.append(queue[0].Right)
            print(queue[0].Val)
            # 剔除当前元素
            queue.pop(0)

if __name__ == '__main__':
    tn = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)),
                  TreeNode(3, TreeNode(6), TreeNode(7)))
    preorder_traversal(tn)  # 1245367
    inorder_traversal(tn)   # 4251637
    postorder_traversal(tn)  # 4526731
    sequence_traversalBFS(tn)  # 1234567
```