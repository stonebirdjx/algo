<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [常见算法及其复杂度](#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%A4%8D%E6%9D%82%E5%BA%A6)
- [:point_right:冒泡排序（Bubble Sort）](#point_right%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8Fbubble-sort)
  - [code-golang](#code-golang)
  - [code-python](#code-python)
- [:point_right:选择排序（Selection Sort）](#point_right%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8Fselection-sort)
  - [code-golang](#code-golang-1)
  - [code-python](#code-python-1)
- [插入排序（Insertion Sort）](#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8Finsertion-sort)
  - [code-golang](#code-golang-2)
  - [code-python](#code-python-2)
- [希尔排序（Shell Sort）](#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8Fshell-sort)
  - [code-golang](#code-golang-3)
  - [code-python](#code-python-3)
- [归并排序（Merge Sort）](#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8Fmerge-sort)
  - [code-golang](#code-golang-4)
  - [code-python](#code-python-4)
- [快速排序（Quick Sort）](#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fquick-sort)
- [堆排序（Heap Sort）](#%E5%A0%86%E6%8E%92%E5%BA%8Fheap-sort)
- [计数排序（Counting Sort）](#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8Fcounting-sort)
- [桶排序（Bucket Sort）](#%E6%A1%B6%E6%8E%92%E5%BA%8Fbucket-sort)
- [基数排序（Radix Sort）](#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8Fradix-sort)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 常见算法及其复杂度

| 算法名称                   | 时间复杂度                | 空间复杂度     |
| -------------------------- | ------------------------- | -------------- |
| 冒泡排序（Bubble Sort）    | O(n^2)                    | O(1)           |
| 选择排序（Selection Sort） | O(n^2)                    | O(1)           |
| 插入排序（Insertion Sort） | O(n^2)                    | O(1)           |
| 希尔排序（Shell Sort）     | O(n*logn)~O(n^2)          | O(1)           |
| 归并排序（Merge Sort）     | O(n*logn)                 | O(n)           |
| 快速排序（Quick Sort）     | O(n*logn) ~ O(n^2)        | O(logn) ~ O(n) |
| 堆排序（Heap Sort）        | O(n*logn)                 | O(1)           |
| 计数排序（Counting Sort）  | O(n+k)                    | O(k)           |
| 桶排序（Bucket Sort）      | O(n+k)                    | O(k)           |
| 基数排序（Radix Sort）     | O(d*(n+k))其中d是数字位数 | O(n+k)         |

# :point_right:冒泡排序（Bubble Sort）

冒泡排序（Bubble Sort）是一种简单的排序算法，它的基本思想是重复地遍历要排序的数组，每次比较相邻的两个元素，如果它们的顺序错误就交换它们。通过多次遍历，将最大的元素依次冒泡到数组的最后面，最终完成排序。

冒泡排序的时间复杂度为O(n^2)，空间复杂度为O(1)，是一种稳定的排序算法。

## code-golang

```Go
// BubbleSort 冒泡排序.
func BubbleSort(arr []int) []int {
    l := len(arr)
    for i := 0; i < l; i++ {
        for j := i + 1; j < l; j++ {
            if arr[i] > arr[j] {
                arr[i], arr[j] = arr[j], arr[i]
            }
        }
    }
    return arr
}
```

## code-python

```Python
def bubble_sort(arr:list[int]) -> list[int]:
    """
    bubble_sort 冒泡排序
    """
    for i in range(len(arr)):
        for j in range(i+1,len(arr)):
            if arr[i] > arr[j]:
                arr[i], arr[j] = arr[j], arr[i]

    return arr
```

# :point_right:选择排序（Selection Sort）

选择排序（Selection Sort）是每次从待排序的元素中选出最小（或最大）的一个元素，放在已排好序的元素的末尾，直到所有元素都排好序为止。

选择排序的时间复杂度为 O(n^2)，空间复杂度为 O(1)，是一种较为简单但效率较低的排序算法，适用于小规模数据的排序。

## code-golang

```Go
// SelectionSort 选择排序.
func SelectionSort(arr []int) []int {
    l := len(arr)
    for i := 0; i < l-1; i++ {
        minIndex := i
        for j := i + 1; j < l; j++ {
            if arr[minIndex] > arr[j] {
                minIndex = j
            }
        }
        arr[i], arr[minIndex] = arr[minIndex], arr[i]
    }

    return arr
}
```

## code-python

```Python
def selection_sort(arr: list[int]) -> list[int]:
    """
    selection_sort 选择排序
    """
    for i in range(len(arr)-1):
        min_index = i
        for j in range(i+1, len(arr)):
            if arr[min_index] > arr[j]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]

    return arr
```

# 插入排序（Insertion Sort）

插入排序（Insertion Sort）基本思想是将一个数插入到已经排好序的有序序列中，形成一个新的有序序列。

具体实现步骤如下：

1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果已排序的元素大于新元素，将该元素移到下一位置；

插入排序的时间复杂度为 O(n^2)，空间复杂度为 O(1)，在实际应用中，对于小规模或基本有序的数据，插入排序的效率比较高。

## code-golang

```Go
// InsertionSort 插入排序
func InsertionSort(arr []int) []int {
    l := len(arr)
    for i := 1; i < l; i++ {
        preIndex := i - 1
        // 保留一份值
        tmp := arr[i]
        for preIndex >= 0 && arr[preIndex] > tmp {
            // 排序好元素比当前大，往后挪动
            arr[preIndex+1] = arr[preIndex]
            preIndex--
        }
        // 插入到当前位置
        arr[preIndex+1] = tmp
    }

    return arr
}
```

## code-python

```Python
def insertion_sort(arr: list[int]) -> list[int]:
    """
    insertion_sort 插入排序
    """
    for i in range(1,len(arr)):
        pre_index = i - 1
        # 临时值
        tmp:int = arr[i]
        while pre_index >= 0 and arr[pre_index] > tmp:
            # 挪动
            arr[pre_index+1] = arr[pre_index]
            pre_index -= 1
        # c插入到正确位置
        arr[pre_index+1] = tmp

    return arr
```

# 希尔排序（Shell Sort）

希尔排序（Shell Sort）,也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

希尔排序的时间复杂度与增量序列的选择有关，最坏情况下为 O(n^2)，平均情况下为 O(nlogn)，空间复杂度为 O(1)

## code-golang

```Go
// ShellSort 希尔排序
func ShellSort(arr []int) []int {
    l := len(arr)
    // 设置gap
    gap := 1
    for gap < l/3 {
        gap = gap*3 + 1
    }
    for gap > 0 {
        for i := gap; i < l; i++ {
            tmp := arr[i]
            // 临时索引
            j := i - gap
            for j >= 0 && arr[j] > tmp {
                arr[j+gap] = arr[j]
                j -= gap
            }
            arr[j+gap] = tmp
        }
        gap = gap / 3
    }
    return arr
}
```

## code-python

```Python
def shell_sort(arr: list[int]) -> list[int]:
    """
    shell_sort 希尔排序
    """
    gap: int = 1
    while gap < len(arr)//3:
        gap = 3*gap + 1
    while gap > 0:
        for i in range(gap, len(arr)):
            tmp = arr[i]
            # 临时索引
            j = i - gap
            while j >= 0 and arr[j] > tmp:
                arr[j+gap] = arr[j]
                j -= gap
            arr[j+gap] = tmp
        gap = gap//3
        
    return arr
```

# 归并排序（Merge Sort）

归并排序（Merge Sort）是一种基于分治思想的排序算法，将待排序的数组分成若干个子序列，将每个子序列排序后再将子序列合并成一个有序序列，直到最终排序完成

具体实现步骤如下：

1. 将待排序的数组不断二分，直到每个子序列只有一个元素为止；
2. 对每个子序列进行排序，可以使用插入排序、选择排序等简单排序算法；
3. 将相邻的子序列两两合并，合并时比较两个子序列的第一个元素，将较小的元素先放入临时数组中，直到其中一个子序列为空，再将另一个子序列中剩余的元素依次放入临时数组中；
4. 重复步骤 3，直到所有的子序列都合并成一个有序序列；

归并排序的时间复杂度为 O(nlogn)，空间复杂度为 O(n)，是一种稳定的排序算法，适用于各种数据规模的排序，但是在实现上需要使用额外的空间，因此不适用于内存有限的场景。

## code-golang

```Go
// MergerSort 归并排序.
func MergerSort(arr []int) []int {
    l := len(arr)
    if l < 2 {
        return arr
    }
    mid := l / 2
    left := MergerSort(arr[:mid])
    right := MergerSort(arr[mid:])
    return meger(left, right)
}

// meger 归并排序处理函数.
func meger(left, right []int) []int {
    res := make([]int, 0)
    for len(left) > 0 && len(right) > 0 {
        if left[0] > right[0] {
            res = append(res, right[0])
            right = right[1:]
        } else {
            res = append(res, left[0])
            left = left[1:]
        }
    }
    if len(left) == 0 {
        res = append(res, right...)
    }
    if len(right) == 0 {
        res = append(res, left...)
    }
    return res
}
```

## code-python

```Python
def merge_sort(arr: list[int]) -> list[int]:
    """
    merge_sort 归并排序
    """
    l = len(arr)
    if l < 2:
        return arr
    mid = l // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return meger(left, right)

def meger(left: list[int], right: list[int]) -> list[int]:
    """
    meger 归并函数处理函数
    """
    res = []
    while len(left) > 0 and len(right) > 0:
        if left[0] > right[0]:
            res.append(right[0])
            right.pop(0)
        else:
            res.append(left[0])
            left.pop(0)

    if len(left) == 0:
        res += right
    if len(right) == 0:
        res += left

    return res
```

# 快速排序（Quick Sort）



# 堆排序（Heap Sort）

# 计数排序（Counting Sort）

# 桶排序（Bucket Sort）

# 基数排序（Radix Sort）