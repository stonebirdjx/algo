<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [简介](#%E7%AE%80%E4%BB%8B)
- [1.两数之和](#1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C)
  - [code-golang](#code-golang)
  - [code-python](#code-python)
- [26. 删除有序数组中的重复项](#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9)
  - [code-golang](#code-golang-1)
  - [code-python](#code-python-1)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 简介

数组是在程序设计中，把具有相同类型的若干元素按有序的形式组织起来的一种形式。

作为线性表的实现方式之一，数组中的元素在内存中是 **连续** 存储的，且每个元素占相同大小的内存。

组通过 **索引** 快速访问每个元素的值。在大多数编程语言中，索引从 0 算起。

# [1.两数之和](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

```bash
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```bash
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```bash
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？

## code-golang

方式一：遍历

```go
func twoSum(nums []int, target int) []int {
	l := len(nums)
	for i := 0; i < l; i++ {
		for j := i + 1; j < l; j++ {
			if nums[i]+nums[j] == target {
				return []int{i, j}
			}
		}
	}
    
	return nil
}
```

方式二：哈希表 map，时间复杂度O(n)

```go
func twoSum(nums []int, target int) []int {
	mp := make(map[int]int)
	for i, v := range nums {
		if j, ok := mp[target-v]; ok {
			return []int{j, i}
		}
		mp[v] = i
	}
    
	return nil
}
```

## code-python

方式一：遍历

```python
class Solution:
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        nums_len = len(nums)
        for i in range(nums_len):
            for j in range(i+1, nums_len):
                if nums[i] + nums[j] == target:
                    return [i, j]

        return None

```

方式二：哈希表 map，时间复杂度O(n)

```python
class Solution:
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        mp = {}
        for i, v in enumerate(nums):
            if target-v in mp.keys():
                return [i, mp[target-v]]
            mp[v] = i

        return Non
```

# [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

**示例 1：**

```bash
输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```bash
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按 **升序** 排列

## code-golang

方法1：双指针

```go
// nums 升序数组。
func removeDuplicates(nums []int) int {
	l := len(nums)
	if l < 2 {
		return l
	}

	slow := 1
	for fast := 1; fast < l; fast++ {
		if nums[fast] != nums[fast-1] {
			// 把fast复制给slow
			nums[slow] = nums[fast]
			slow++
		}
	}
	// nums = nums[:slow]
	return slow
}
```

## code-python

方法1：双指针

```python
class Solution:
    def removeDuplicates(self, nums: list[int]) -> int:
        l = len(nums)
        if l < 2:
            return l

        slow = 1
        for fast in range(1, l):
            if nums[fast] != nums[fast-1]:
                nums[slow] = nums[fast]
                slow += 1

        # nums = nums[:slow]
        return slow
```

