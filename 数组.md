<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [简介](#%E7%AE%80%E4%BB%8B)
- [两数之和](#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C)
  - [code-golang](#code-golang)
  - [code-python](#code-python)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 简介

数组是在程序设计中，把具有相同类型的若干元素按有序的形式组织起来的一种形式。

作为线性表的实现方式之一，数组中的元素在内存中是 **连续** 存储的，且每个元素占相同大小的内存。

组通过 **索引** 快速访问每个元素的值。在大多数编程语言中，索引从 0 算起。

# [两数之和](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

```bash
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```bash
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```bash
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？

## code-golang

方式一：遍历

```go
func twoSum(nums []int, target int) []int {
	l := len(nums)
	for i := 0; i < l; i++ {
		for j := i + 1; j < l; j++ {
			if nums[i]+nums[j] == target {
				return []int{i, j}
			}
		}
	}
    
	return nil
}
```

方式二：哈希表 map，时间复杂度O(n)

```go
func twoSum(nums []int, target int) []int {
	mp := make(map[int]int)
	for i, v := range nums {
		if j, ok := mp[target-v]; ok {
			return []int{j, i}
		}
		mp[v] = i
	}
    
	return nil
}
```

## code-python

方式一：遍历

```python
class Solution:
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        nums_len = len(nums)
        for i in range(nums_len):
            for j in range(i+1, nums_len):
                if nums[i] + nums[j] == target:
                    return [i, j]

        return None

```

方式二：哈希表 map，时间复杂度O(n)

```python
class Solution:
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        mp = {}
        for i, v in enumerate(nums):
            if target-v in mp.keys():
                return [i, mp[target-v]]
            mp[v] = i

        return Non
```

